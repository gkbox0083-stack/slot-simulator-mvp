# v1.5.2 Scatter + FSM Specification

## 版本資訊
- **版本**: v1.5.2
- **功能**: Scatter Trigger + FSM State Management
- **日期**: 2024

---

## 1. Scope（範圍與限制）

### 1.1 功能範圍
- ✅ Scatter 符號觸發 FREE Game（BASE state 觸發）
- ✅ FSM 狀態管理（BASE ↔ FREE）
- ✅ Scatter 符號在 grid 上的放置（獨立 layer）
- ✅ Scatter count 與 trigger outcome 的一致性驗證

### 1.2 明確禁止事項（v1.5.2 不實作）
- ❌ **No retrigger**: FREE table 不得含 FEATURE 類型 outcome
- ❌ **No win+feature**: Trigger outcome 必須是純 FEATURE（payout=0），不得同時驗證 line win
- ❌ **No any-position pay**: 不做 any-position pay / multi-win
- ❌ **No scatter paytable**: 不做 scatter payout（scatter 僅用於觸發）
- ❌ **No scatter visual design**: 不做 tease/near-miss 的 scatter 心理設計

### 1.3 與既有功能的關係
- v1.5.2 的 Scatter Layer 是**獨立 layer**，不重構既有 resolver pipeline
- 既有 pattern generation / visual constraints 保持不變
- Scatter 符號必須在 base grid 生成**之後**套用（覆寫策略）

---

## 2. Truth Source 語義（事件真源 vs 規則真源）

### 2.1 Outcome Truth Source（事件真源）
**定義**: `outcomeTables` 決定「本 spin outcome（含是否觸發 FREE）」是唯一事件真源。

**語義**:
- `outcome.type === 'FEATURE'` 且 `outcome.id` 匹配 `scatterConfig.trigger.featureId` → **觸發 FREE**
- 所有其他 outcome → **不觸發**

**關鍵規則**:
- Outcome 選擇發生在 **FSM 狀態確定之後**（BASE 抽 BASE table，FREE 抽 FREE table）
- Outcome 一旦選定，**不可修改**（Truth Source 不變）
- Scatter count 必須與 outcome 一致（STRICT 驗證）

### 2.2 Config Truth Source（規則真源）
**定義**: `config` 定義「觸發門檻 minCount / 可觸發 state / 視覺落地規則」。

**結構**:
```json
{
  "scatterConfig": {
    "scatterSymbolId": "S",
    "trigger": {
      "minCount": 3,
      "states": ["BASE"],
      "featureId": "FREE_GAME_TRIGGER"
    },
    "placement": {
      "mode": "RANDOM_ANYWHERE",
      "maxCount": 5
    }
  },
  "fsmConfig": {
    "initialState": "BASE",
    "states": ["BASE", "FREE"],
    "transitions": [
      { "from": "BASE", "on": "TRIGGER_FREE", "to": "FREE" },
      { "from": "FREE", "on": "FREE_SPINS_END", "to": "BASE" }
    ]
  }
}
```

**語義**:
- `scatterConfig.trigger.minCount`: 觸發所需的 scatter 數量（必須剛好等於）
- `scatterConfig.trigger.states`: 可觸發的狀態列表（v1.5.2 僅 BASE）
- `scatterConfig.trigger.featureId`: 觸發時對應的 outcome.id（必須是 FEATURE 類型）

---

## 3. Scatter 行為（消歧義策略）

### 3.1 Trigger 情況（BASE + outcome=FEATURE/FREE_GAME_TRIGGER）
**規則**: `scatterCount` 必須「剛好 == minCount」

**執行流程**:
1. Outcome 已選定：`outcome.type === 'FEATURE'` 且 `outcome.id === scatterConfig.trigger.featureId`
2. Scatter Layer 目標：在 grid 上放置 **exactly minCount** 個 scatter 符號
3. STRICT 驗證：最終 `scatterCount === minCount`，否則 throw

**放置策略**:
- 使用 `scatterConfig.placement.mode`（v1.5.2: `RANDOM_ANYWHERE`）
- 覆寫 grid 上的非保護位置（v1.5.2 不保護 line win，因為禁止 WIN_AND_FEATURE）
- 使用 seeded RNG 選位置（確保 deterministic）

### 3.2 Non-trigger 情況（任何非觸發 outcome）
**規則**: `scatterCount` 必須「固定 == 0」（v1.5.2 最保守）

**執行流程**:
1. Outcome 已選定：非 FEATURE 或 FEATURE 但 id 不匹配
2. Scatter Layer 目標：確保 grid 上 **0 個 scatter 符號**
3. STRICT 驗證：最終 `scatterCount === 0`，否則 throw

**清理策略**:
- 如果 base grid 已包含 scatter 符號，必須清除（覆寫為非 scatter）
- 使用 seeded RNG 選替換符號（確保 deterministic）

### 3.3 重試與 Fallback
**重試機制**:
- 有限重試（例如 20 次）
- 每次重試使用不同的 RNG seed（基於 retry count）
- 若重試失敗，允許 fallback（但必須符合 Truth Source）

**Fallback 策略**:
- 優先 Truth Source：觸發與否必須與 scatterCount 相容
- 若無法達成目標 scatterCount，記錄警告並 fallback 到最接近的合法狀態

---

## 4. FSM 規格（含 off-by-one 規則）

### 4.1 狀態定義
```typescript
type State = "BASE" | "FREE";
```

**狀態語義**:
- `BASE`: Base Game 狀態，每次 spin 扣除 bet
- `FREE`: Free Game 狀態，每次 spin 不扣除 bet，使用 FREE outcome table

### 4.2 狀態變數
```typescript
{
  state: State;                    // 當前狀態
  freeSpinsRemaining: number;      // FREE 狀態剩餘次數（BASE 時為 0）
}
```

### 4.3 STRICT Guards（每 spin 開始）
```javascript
// Guard 1: FREE 狀態必須有剩餘次數
if (state === "FREE" && freeSpinsRemaining <= 0) {
  throw new Error(`Invalid state: FREE with freeSpinsRemaining=${freeSpinsRemaining}`);
}

// Guard 2: BASE 狀態不得有剩餘次數
if (state === "BASE" && freeSpinsRemaining > 0) {
  throw new Error(`Invalid state: BASE with freeSpinsRemaining=${freeSpinsRemaining}`);
}
```

### 4.4 轉移規則（避免 off-by-one）

#### 轉移 1: BASE → FREE（觸發）
**觸發條件**:
- `state === "BASE"`
- `outcome.type === "FEATURE"`
- `outcome.id === scatterConfig.trigger.featureId`

**執行**:
```javascript
after.state = "FREE";
after.freeRemaining = config.featureConfig.freeSpinCount;  // 例如 10
```

**Off-by-one 保護**:
- 觸發當次 spin **不扣除** freeSpinsRemaining
- 觸發當次 spin 仍視為 BASE spin（計入 baseSpins）

#### 轉移 2: FREE → BASE（結束）
**觸發條件**:
- `state === "FREE"`
- `freeSpinsRemaining > 0`（spin 完成後）

**執行**:
```javascript
// Spin 完成後
freeSpinsRemaining--;

// 若歸零，轉回 BASE
if (freeSpinsRemaining <= 0) {
  after.state = "BASE";
  after.freeRemaining = 0;
}
```

**Off-by-one 保護**:
- 每次 FREE spin 完成後才扣除
- 最後一次 FREE spin（freeSpinsRemaining === 1）完成後，扣除後歸零，下一局轉回 BASE

### 4.5 Outcome 選擇規則
```javascript
// BASE 狀態
if (state === "BASE") {
  outcome = selectOutcome(rng, outcomeTables.BASE, "BASE");
  // STRICT: 若 outcome.type === "FEATURE"，必須匹配 scatterConfig.trigger.featureId
}

// FREE 狀態
if (state === "FREE") {
  outcome = selectOutcome(rng, outcomeTables.FREE, "FREE");
  // STRICT: 若 outcome.type === "FEATURE"，必須 throw（禁止 retrigger）
}
```

---

## 5. outcomeTables 規格

### 5.1 BASE Table
**允許的 outcome 類型**:
- `WIN`: 一般中獎
- `LOSS`: 未中獎
- `FEATURE`: 觸發 FREE（必須匹配 `scatterConfig.trigger.featureId`）

**範例**:
```json
{
  "id": "FREE_GAME_TRIGGER",
  "weight": 10,
  "payoutMultiplier": 0,
  "type": "FEATURE"
}
```

**STRICT 驗證**:
- 若 `outcome.type === "FEATURE"` 且 `outcome.payoutMultiplier > 0` → throw（禁止 WIN_AND_FEATURE）
- 若 `outcome.type === "FEATURE"` 且 `outcome.id !== scatterConfig.trigger.featureId` → throw（必須匹配）

### 5.2 FREE Table
**允許的 outcome 類型**:
- `WIN`: 一般中獎
- `LOSS`: 未中獎
- ❌ **禁止 `FEATURE`**: 避免 retrigger

**STRICT 驗證**:
- 若 `outcome.type === "FEATURE"` → throw（禁止 retrigger）

### 5.3 Schema 驗證規則
```javascript
// Validator 必須檢查：
// 1. fsmConfig 包含 FREE 時，gameRules.FREE 缺失 => STRICT throw
// 2. outcomeTables.FREE 出現 FEATURE => STRICT throw
// 3. trigger outcome 出現 win+feature => STRICT throw（v1.5.2 禁止）
```

---

## 6. Telemetry 結構

### 6.1 Spin Result 結構
```typescript
{
  spinIndex: number;                    // 全局 spin 索引
  state: {
    before: State;                       // Spin 前狀態
    after: State;                        // Spin 後狀態
    freeRemainingBefore: number;         // Spin 前剩餘次數
    freeRemainingAfter: number;          // Spin 後剩餘次數
  },
  outcome: Outcome;                      // 選定的 outcome
  grid: Grid;                            // 最終 grid（含 scatter）
  winEvents: WinEvent[];                 // Evaluator 結果（0~1 個）
  scatter: {
    count: number;                       // 最終 scatter 數量
    guardApplied: boolean;                // 是否應用 guard（清理/放置）
    attemptsUsed: number;                // 重試次數
    fallbackUsed: boolean;               // 是否使用 fallback
  }
}
```

### 6.2 CSV/Reporter 欄位
新增欄位：
- `stateBefore`: State（"BASE" | "FREE"）
- `stateAfter`: State（"BASE" | "FREE"）
- `freeRemainingAfter`: number
- `scatterCount`: number
- `scatterGuardApplied`: boolean
- `scatterFallbackUsed`: boolean

---

## 7. Acceptance Checklist + P0 Gate

### 7.1 機械驗收腳本要求
必須新增：`logic/tests/v1.5.2/acceptance_fsm_scatter.test.js`（或 `scripts/v1.5.2_acceptance.js`）

**必驗項目**:
1. ✅ 每個 FREE trigger 後，FREE spins 數量剛好 == N（`config.featureConfig.freeSpinCount`）
2. ✅ 同 seed 兩次 run：outcome/state/scatterCount 序列完全一致（determinism）
3. ✅ evaluator 每 spin 呼叫次數 == 1（single evaluation point）
4. ✅ STRICT_MODE mismatch == 0（所有 spin 通過 strict validation）
5. ✅ Trigger 時 `scatterCount === minCount`（STRICT）
6. ✅ Non-trigger 時 `scatterCount === 0`（STRICT）
7. ✅ FREE table 不含 FEATURE（STRICT）
8. ✅ Trigger outcome 不得是 WIN_AND_FEATURE（STRICT）

### 7.2 P0 Gate 指標
執行命令：
```bash
node logic/cli.js -n 200 --seed 123 --strict
node logic/cli.js -n 2000 --seed 123 --strict
```

**輸出指標**:
- `freeTriggerRate`: BASE spins 觸發 FREE 比例（應接近 outcome weight 比例）
- `scatterCount` 分布：
  - BASE（non-trigger）: 幾乎全為 0
  - BASE（trigger）: 全部 == minCount
  - FREE: 幾乎全為 0
- `guardApplied` 次數: Scatter layer 應用 guard 的次數
- `fallbackUsed` 次數: Scatter layer 使用 fallback 的次數（應接近 0）

**失敗條件**:
- STRICT_MODE 出現 mismatch → 立即停止
- Determinism 測試失敗 → 立即停止
- Evaluator 呼叫次數 != 1 → 立即停止

---

## 8. 實作順序（Step-by-Step）

1. **Step 1**: 建立規範真源文件（本文件）✅
2. **Step 2**: Config / Schema 更新
3. **Step 3**: FSM 實作（simulate.js）
4. **Step 4**: Resolver Scatter Layer（獨立 layer）
5. **Step 5**: Reporter/CSV 更新
6. **Step 6**: Acceptance 測試腳本
7. **Step 7**: Branch A P0 Gate 驗證

---

## 9. 關鍵設計決策

### 9.1 Scatter Layer 獨立性
- Scatter Layer 是**獨立 layer**，不重構既有 resolver pipeline
- 在 base grid 生成後套用（覆寫策略）
- 使用 seeded RNG 確保 deterministic

### 9.2 Truth Source 優先
- Outcome 決定觸發與否（Truth Source）
- Scatter count 必須與 outcome 一致（STRICT 驗證）
- 若無法達成目標，優先 fallback 而非修改 outcome

### 9.3 保守策略（v1.5.2）
- Non-trigger 時 scatterCount 固定 == 0（最保守）
- 禁止 WIN_AND_FEATURE（避免複雜性）
- 禁止 retrigger（避免複雜性）

---

## 10. 參考文件
- Branch A Invariant Spec: `docs/v1.5/spec/BranchA_Invariant_Spec.md`
- v1.5.0 Core Contracts: `docs/v1.5/interfaces/v1.5_core_contracts.md`
- v1.5.1 Wild Spec: `docs/v1.5/spec/v1.5.1_wild_minspec.md`

