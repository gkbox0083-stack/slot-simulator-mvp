# v1.5.0 — Pay Rule Engine（Cursor Ready Prompt / v2）

> **Scope**: Slot Math IDE – Math Core Evolution  
> **Phase**: v1.5.0 (Rule Engine Foundation / Verification Mode)  
> **Status**: Cursor-ready, strict-spec (v2: fixes coord/signature/flow gaps)

---

## 0. 決策鎖定（不可自行更動）

- WinEvent[] 資料結構：**允許**（v1.5.0 僅 0~1 個事件）
- Wild 替代 Scatter：**不允許**
- Any-position 與 LINE 同時得獎：**v1.5.3 前不允許**
- **Truth Source（v1.5.0~v1.5.3）**  
  Outcome 定義 expected payout；Evaluator 為 deterministic verifier + explainer
- **Single Evaluation Point**  
  每個 spin evaluator 只能呼叫一次（由 simulate pipeline 統一；resolver/visual 不得呼叫）

---

## 1. 目標

- 將 LINE-pay 中獎邏輯由 if-else 搬遷至 Rule Evaluator（Grid → WinEvent[]）
- 不影響 outcome 抽選、RTP、FSM、RNG
- 建立 WinEvent[] 輸出介面（IDE / UI Ready）
- 啟用 CSV / Telemetry Shadow Mode（expected vs evaluated）

---

## 2. In / Out Scope

### In Scope
- Rule interface + evaluator
- LINE rule（單事件）
- VisualConstraint 介面升級（相容 v1.4）
- simulate.js 統一呼叫 evaluator + strict validation
- reporter.csv 影子欄位

### Out of Scope（明確禁止）
- Wild / Scatter / Any-position / Multi-win
- Outcome 機率或 RNG 行為變更
- Visual semantics 重寫（只允許相容性介面調整）

---

## 3. 核心工程圍欄

### G1. Truth Source（v1.5.0~v1.5.3）

```ts
expectedWin = outcome.payoutMultiplier * bet   // integer credits
evaluatedWin = sum(winEvents.winAmount)

STRICT_MODE = true:
  if evaluatedWin !== expectedWin → throw error
```

- WinEvent.winAmount **必須為整數 credit**
- 若 bet 可能是浮點（例如貨幣），必須先轉成最小單位（credit/cents）再進入 math core
- v1.5.0 驗收要求：STRICT_MODE=true 且 0 mismatch

---

### G2. Single Evaluation Point

- resolver.js：Outcome → Grid（**不呼叫** evaluator）
- simulate.js：唯一呼叫點 `evaluator.evaluate(grid, ruleContext)`
- visualConstraint：只讀結果（不得 evaluate、不得掃 grid 判定中獎）

---

### G3. Visual Layer 不得猜測

- LINE WinEvent **必須提供 positions**
- visual layer 不可由 grid 掃描中獎格、不可以 outcome 推測中獎位置
- 過渡期允許 fallback legacyWinLine（僅在 winEvents 缺失時）

---

## 4. WinEvent 結構（v1.5.0）

> **重要：座標系統必須與 design.json 的 paylines 定義一致。**  
> v1.5.0 強制使用 **[row, col]**（row-major）

```ts
WinEvent {
  eventId: string,
  ruleType: 'LINE',
  winAmount: number,                  // credit int
  paidSymbolId: string,
  displaySymbolId: string,
  positions: Array<[row, col]>,       // ✅ [row, col] 與 paylines 一致
  matchCount?: number,
  paylineIndex?: number,
  metadata?: {}
}
```

限制：`winEvents.length ∈ {0,1}`  
（多事件一律延後到 v1.5.4）

> **NOTE（v1.5.0 簡化）**：不引入 `WinEvent.source` 欄位。v1.5.0 事件全部都是 evaluator 產生。

---

## 5. Resolver / Visual 介面遷移（雙寫期）

### 5.1 Resolver 回傳（v1.5.0）

> **統一規則**：resolver 不回傳 winEvents（避免職責混淆）。

```ts
{
  grid,
  winLine: number | null   // legacy fallback（v1.5.0~v1.5.1 暫留）
}
```

### 5.2 VisualConstraint.applyConstraints（保持 positional 風格，降低改動範圍）

> **必須保留 outcome**（near-miss / tease 會用 outcome.id/type/winConfig）。

```ts
applyConstraints(
  grid,
  outcome,
  winEvents,        // v1.5.0 新增
  context,
  legacyWinLine?    // v1.5.0 暫留
)
```

### 5.3 Visual protectedCells 推導（嚴格順序）

```ts
// Priority 1: use winEvents[0].positions (no guessing)
if (winEvents?.length > 0 && winEvents[0].positions?.length > 0) {
  protectedCells = winEvents[0].positions
}

// Priority 2: fallback to legacyWinLine (v1.5.0 transitional only)
else if (legacyWinLine != null) {
  // use design/gameRule.paylines[legacyWinLine] + outcome.winConfig.matchCount (or equivalent)
  protectedCells = deriveFromLegacy(legacyWinLine, outcome)
}

// Priority 3: LOSS → protectedCells empty
else {
  protectedCells = []
}
```

禁止：
- ❌ 從 grid 掃描中獎格（會與 evaluator 重疊/不一致）
- ❌ 從 outcome 猜 positions（只能用 legacyWinLine fallback 路徑）

---

## 6. simulate.js 實作流程（唯一入口）

```ts
// 1) Resolver 生成 grid（不變）
const { grid, winLine } = resolver.resolve(outcome, ctx)

// 2) Evaluator（唯一呼叫點）
const winEvents = evaluator.evaluate(grid, ruleContext)  // 0~1 event

// 3) Strict Validation（v1.5.0 必做）
const v = validateStrict(outcome, bet, winEvents, STRICT_MODE)

// 4) Visual（保留 outcome + legacy fallback）
visual.applyConstraints(grid, outcome, winEvents, ctx, winLine)

// 5) Reporter / CSV
reporter.writeRow({
  ...legacyFields,
  ...v,
  evaluatedEventCount: winEvents.length,
  evaluatedRuleTypes: winEvents.map(e => e.ruleType).join('|'),
  eventsJson: JSON.stringify(winEvents) // optional
})
```

### 6.1 validateStrict 參考實作（請落在 simulate.js）

```ts
function validateStrict(outcome, bet, winEvents, STRICT_MODE = true) {
  const expectedWinAmount = outcome.payoutMultiplier * bet  // credit int
  const evaluatedWinAmount = winEvents.reduce((s, e) => s + e.winAmount, 0)
  const evaluationMatch = (expectedWinAmount === evaluatedWinAmount)

  if (STRICT_MODE && !evaluationMatch) {
    throw new Error(
      `Validation mismatch: expected=${expectedWinAmount}, evaluated=${evaluatedWinAmount}, ` +
      `outcome=${outcome.id}, events=${JSON.stringify(winEvents)}`
    )
  }

  return { expectedWinAmount, evaluatedWinAmount, evaluationMatch }
}
```

---

## 7. CSV / Telemetry（Shadow Mode）

**保留**
- outcomeId
- winAmount
- isWin

**新增**
- expectedWinAmount
- evaluatedWinAmount
- evaluationMatch
- evaluatedEventCount
- evaluatedRuleTypes
- eventsJson（optional，強烈建議）

---

## 8. 驗收 Checklist（Blocker）

- Same seed → same outcome / win / RTP（v1.4 vs v1.5.0）
- STRICT_MODE=true → 0 mismatch（evaluationMatch 全為 true）
- 視覺 guard 不破壞中獎格（protectedCells 以 positions 優先）
- CSV 可逐列對帳 expected vs evaluated

---

## 9. 禁止事項（再強調一次）

- ❌ resolver 內呼叫 evaluator
- ❌ evaluator 修改 grid
- ❌ visual layer 掃 grid 判定中獎
- ❌ v1.5.0 嘗試 multi-win（多事件）

---

**End of v1.5.0 Cursor Ready Prompt (v2)**
